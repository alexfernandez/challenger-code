const {expect} = require('chai')
const {ApiError, TestError} = require('../../lib/model/error.js')
const {Challenge} = require('../../lib/model/challenge.js')


const data = {
	id: 'test',
	category: 'test',
	name: 'Test',
	description: 'Return 0 always',
	implementation: 'function solve() {return 0}',
	verifications: [{
		public: true,
		name: 'Empty',
		input: [],
		output: 0,
	}, {
		public: false,
		name: 'Array with many elements',
		input: [[1,2,3,4,5]],
		output: 0,
	}, {
		public: false,
		name: 'Autogenerated',
		input: ['array', 'number'],
		array: 'function generate() {const array = []; for (let i = 0; i < 1000; i++) array.push(i); return array}',
		number: 'function generate() {return Math.floor(Math.random() * 1000)}',
		output: 0,
	}],
	maxMinutes: 5,
	runningTimeoutSeconds: 1,
}

describe('Challenge model tests', function() {
	this.timeout(5000)
	let challenge = null
	it('should create challenge', async() => {
		challenge = new Challenge(data)
		await challenge.init()
		expect(challenge.id).to.equal('test')
		expect(challenge).to.have.property('verifications')
		expect(challenge.verifications.length).to.equal(3)
		const last = challenge.verifications[2]
		expect(last).to.have.property('input')
		expect(last.input.length).to.equal(2)
		const array = last.input[0]
		expect(array.length).to.equal(1000)
		for (let i = 0; i < array.length; i++) {
			expect(array[i]).to.equal(i)
		}
		const number = last.input[1]
		expect(number).to.be.above(0)
		expect(number).to.be.below(1000)
	})
	it('should run challenge', async() => {
		const successful = await challenge.runSandboxed('function solve() {return 0}')
		expect(successful.success).to.equal(true)
		const failed = await challenge.runSandboxed('function solve() {return 1}')
		expect(failed.success).to.equal(false)
	})
	it('should reject malicious code', async() => {
		try {
			await challenge.runSandboxed(`const fs = require("fs");
			const solve = () => fs.readFileSync("/etc/resolv.conf")`)
			throw new TestError('Should not run require()')
		} catch(error) {
			expect(error.constructor.name).to.equal('VMError')
		}
		try {
			await challenge.runSandboxed(`import {readFileSync} from "fs";
			const solve = () => fs.readFileSync("/etc/resolv.conf")`)
			throw new TestError('Should not run import')
		} catch(error) {
			expect(error).to.be.instanceof(SyntaxError)
		}
	})
	it('should run in a separate process', async() => {
		const successful = await challenge.runIsolated('function solve() {return 0}')
		expect(successful.success).to.equal(true)
		const failed = await challenge.runIsolated('function solve() {return 1}')
		expect(failed.success).to.equal(false)
		try {
			await challenge.runIsolated('function solve() {while (true){}}')
			throw new TestError('Should not finish infinite loop')
		} catch(error) {
			console.error(error)
			expect(error).to.be.instanceof(ApiError)
		}
	})
})

